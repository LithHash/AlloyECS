"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[706],{460:e=>{e.exports=JSON.parse('{"functions":[{"name":"entity","desc":"Creates a new entity and returns its ID.\\nEntity IDs are recycled with incremented generations when entities are destroyed.\\n\\n:::info Entity IDs\\nEntity IDs encode both an index (24 bits) and a generation (8 bits).\\nUse [AlloyECS.decodeEntityIndex] and [AlloyECS.decodeEntityGeneration] to extract these values.\\n:::\\n\\n```lua\\nlocal entity = world:entity()\\nworld:set(entity, Position, Vector3.zero)\\n```","params":[],"returns":[{"desc":"The new entity ID","lua_type":"number"}],"function_type":"method","tags":["Entity"],"source":{"line":352,"path":"src/init.luau"}},{"name":"isAlive","desc":"Checks if an entity is currently alive in the world.\\n\\n:::warning Stale Entity IDs\\nAlways check `isAlive` before using a stored entity ID, as the entity may have been destroyed\\nand its ID recycled.\\n:::\\n\\n```lua\\nif world:isAlive(entity) then\\n\\t-- Safe to use entity\\n\\tlocal pos = world:get(entity, Position)\\nend\\n```","params":[{"name":"entityId","desc":"The entity ID to check","lua_type":"number"}],"returns":[{"desc":"True if the entity exists and is alive","lua_type":"boolean"}],"function_type":"method","tags":["Entity"],"source":{"line":402,"path":"src/init.luau"}},{"name":"destroy","desc":"Destroys an entity, removing all its components and relationships.\\nThe entity\'s index will be recycled with an incremented generation.\\n\\nThis will trigger [World:onRemove] hooks for all components on the entity.\\n\\n```lua\\nworld:destroy(entity)\\n```","params":[{"name":"entityId","desc":"The entity ID to destroy","lua_type":"number"}],"returns":[],"function_type":"method","tags":["Entity"],"source":{"line":423,"path":"src/init.luau"}},{"name":"getEntityCount","desc":"Returns the total number of living entities in the world.\\n\\n```lua\\nprint(\\"Entities:\\", world:getEntityCount())\\n```","params":[],"returns":[{"desc":"The number of living entities","lua_type":"number"}],"function_type":"method","tags":["Entity"],"source":{"line":490,"path":"src/init.luau"}},{"name":"getEntities","desc":"Returns an array containing all living entity IDs.\\n\\n:::tip Performance\\nFor iteration, consider using [World:each] or [World:query] instead,\\nas they don\'t create a new array.\\n:::\\n\\n```lua\\nfor _, entityId in world:getEntities() do\\n\\tprint(entityId)\\nend\\n```","params":[],"returns":[{"desc":"Array of all living entity IDs","lua_type":"{number}"}],"function_type":"method","tags":["Entity"],"source":{"line":513,"path":"src/init.luau"}},{"name":"component","desc":"Creates a new component type and returns its ID.\\n\\n| Storage Type | Description | Use Case |\\n|--------------|-------------|----------|\\n| `\\"sparse\\"` | Standard component with data (default) | Most components |\\n| `\\"dense\\"` | *(Coming soon)* Optimized for components on most entities | Components on 50%+ entities |\\n| `\\"tag\\"` | No data, just marks entities | Flags like `Player`, `Enemy` |\\n\\n:::tip Tags\\nFor tag components (no data), use [World:tag] as a shorthand.\\n:::\\n\\n```lua\\nlocal Position = world:component()\\nlocal Health = world:component({ storage = \\"sparse\\" })\\nlocal Visible = world:component({ storage = \\"tag\\" })\\n```","params":[{"name":"config","desc":"Optional configuration","lua_type":"{ storage: \\"sparse\\" | \\"dense\\" | \\"tag\\" }?"}],"returns":[{"desc":"The component ID","lua_type":"number"}],"function_type":"method","tags":["Component"],"source":{"line":546,"path":"src/init.luau"}},{"name":"tag","desc":"Creates a new tag component (a component with no data).\\nTags are useful for marking entities without storing any values.\\n\\nThis is equivalent to `world:component({ storage = \\"tag\\" })`.\\n\\n```lua\\nlocal Player = world:tag()\\nlocal Enemy = world:tag()\\n\\nworld:add(entity, Player)\\n\\n-- Tags work in queries but return nil for their value\\nfor entityId in world:query(Player) do\\n\\tprint(\\"Found player:\\", entityId)\\nend\\n```","params":[],"returns":[{"desc":"The tag component ID","lua_type":"number"}],"function_type":"method","tags":["Component"],"source":{"line":590,"path":"src/init.luau"}},{"name":"isTag","desc":"Checks if a component is a tag (has no data).\\n\\n```lua\\nif world:isTag(componentId) then\\n\\tworld:add(entity, componentId)\\nelse\\n\\tworld:set(entity, componentId, defaultValue)\\nend\\n```","params":[{"name":"componentId","desc":"The component ID to check","lua_type":"number"}],"returns":[{"desc":"True if the component is a tag","lua_type":"boolean"}],"function_type":"method","tags":["Component"],"source":{"line":611,"path":"src/init.luau"}},{"name":"add","desc":"Adds a tag or component (with value `true`) to an entity.\\nUse [World:set] instead if you need to store a specific value.\\n\\nTriggers [World:onAdd] hooks.\\n\\n```lua\\nworld:add(entity, Player)\\nworld:add(entity, Visible)\\n```","params":[{"name":"entityId","desc":"The entity to add the component to","lua_type":"number"},{"name":"componentId","desc":"The component/tag to add","lua_type":"number"}],"returns":[],"function_type":"method","tags":["Component"],"source":{"line":714,"path":"src/init.luau"}},{"name":"set","desc":"Sets a component value on an entity. If the entity doesn\'t have the component,\\nit will be added.\\n\\n- Triggers [World:onAdd] hook if the component is new\\n- Triggers [World:onChange] hook if updating an existing value\\n\\n```lua\\nworld:set(entity, Position, Vector3.new(0, 10, 0))\\nworld:set(entity, Health, 100)\\n```","params":[{"name":"entityId","desc":"The entity to set the component on","lua_type":"number"},{"name":"componentId","desc":"The component ID","lua_type":"number"},{"name":"value","desc":"The value to store","lua_type":"any"}],"returns":[],"function_type":"method","tags":["Component"],"source":{"line":760,"path":"src/init.luau"}},{"name":"get","desc":"Gets a component value from an entity. Returns nil for tags or missing components.\\n\\n:::info Tags\\nFor tags, use [World:has] to check presence since `get` returns nil.\\n:::\\n\\n```lua\\nlocal pos = world:get(entity, Position)\\nif pos then\\n\\tprint(pos.X, pos.Y, pos.Z)\\nend\\n```","params":[{"name":"entityId","desc":"The entity to get the component from","lua_type":"number"},{"name":"componentId","desc":"The component ID","lua_type":"number"}],"returns":[{"desc":"The component value, or nil if not present","lua_type":"any"}],"function_type":"method","tags":["Component"],"source":{"line":819,"path":"src/init.luau"}},{"name":"has","desc":"Checks if an entity has one or more components (including tags).\\n\\n```lua\\n-- Check single component\\nif world:has(entity, Position) then\\n\\t-- ...\\nend\\n\\n-- Check multiple components\\nif world:has(entity, Position, Velocity) then\\n\\t-- Entity has both Position and Velocity\\nend\\n\\n-- Works with tags too\\nif world:has(entity, Player) then\\n\\t-- Entity is a player\\nend\\n```","params":[{"name":"entityId","desc":"The entity to check","lua_type":"number"},{"name":"...","desc":"One or more component IDs","lua_type":"number"}],"returns":[{"desc":"True if the entity has all specified components","lua_type":"boolean"}],"function_type":"method","tags":["Component"],"source":{"line":860,"path":"src/init.luau"}},{"name":"remove","desc":"Removes a component from an entity.\\n\\nTriggers [World:onRemove] hook with the old value.\\n\\n```lua\\nworld:remove(entity, Velocity)\\n```","params":[{"name":"entityId","desc":"The entity to remove the component from","lua_type":"number"},{"name":"componentId","desc":"The component ID to remove","lua_type":"number"}],"returns":[],"function_type":"method","tags":["Component"],"source":{"line":898,"path":"src/init.luau"}},{"name":"query","desc":"Queries for entities that have all specified components.\\nReturns a query object that yields the entity ID followed by component values.\\n\\n```lua\\n-- Simple query (direct iteration)\\nfor entityId, position in world:query(Position) do\\n\\tprint(entityId, position)\\nend\\n\\n-- Multiple components\\nfor entityId, pos, vel in world:query(Position, Velocity) do\\n\\tworld:set(entityId, Position, pos + vel * deltaTime)\\nend\\n\\n-- With filters (call :iter() after filters)\\nfor entityId, pos in world:query(Position):with(Player):without(Dead):iter() do\\n\\t-- Only living players with Position\\nend\\n```\\n\\n:::tip Query Caching\\nQueries are cached for performance. The cache is automatically\\ninvalidated when entities or components change.\\n:::\\n\\n:::info Filter Methods\\nThe query result supports chainable filter methods:\\n- `:with(...)` - Require components without returning their values\\n- `:without(...)` - Exclude entities with these components\\n- `:iter()` - Execute the filtered query (required when using filters)\\n:::","params":[{"name":"...","desc":"Component IDs to query for","lua_type":"number"}],"returns":[{"desc":"A query object that can be iterated directly or filtered with `:with()` / `:without()`","lua_type":"QueryBuilder"}],"function_type":"method","tags":["Query"],"source":{"line":1186,"path":"src/init.luau"}},{"name":"queryBuilder","desc":"Creates a query builder for more complex queries with filters.\\n\\n:::tip Use query() Instead\\n[World:query] now supports the same `:with()` and `:without()` modifiers.\\nThis method is provided for backwards compatibility.\\n:::\\n\\n```lua\\n-- Preferred: use query() directly\\nfor entityId, pos in world:query(Position):with(Player):without(Dead):iter() do\\n\\t-- pos is returned, Player is required but not returned\\nend\\n\\n-- Also works: explicit queryBuilder\\nfor entityId, pos in world:queryBuilder(Position):with(Player):without(Dead):iter() do\\n\\t-- Same result\\nend\\n```","params":[{"name":"...","desc":"Component IDs to query for (values will be returned)","lua_type":"number"}],"returns":[{"desc":"A query builder for adding filters","lua_type":"QueryBuilder"}],"function_type":"method","tags":["Query","Advanced"],"source":{"line":1224,"path":"src/init.luau"}},{"name":"added","desc":"Returns entities that had the specified component added this frame.\\n\\n:::warning Requires Change Tracking\\nThis method requires `trackChanges = true` in [AlloyECS.createWorld] config.\\n:::\\n\\n```lua\\nfor _, entityId in world:added(Position) do\\n\\tprint(\\"Entity gained Position:\\", entityId)\\nend\\n```","params":[{"name":"componentId","desc":"The component ID to check","lua_type":"number"}],"returns":[{"desc":"Array of entity IDs that had this component added","lua_type":"{number}"}],"function_type":"method","tags":["Reactive"],"source":{"line":1372,"path":"src/init.luau"}},{"name":"removed","desc":"Returns entities that had the specified component removed this frame.\\n\\n:::warning Requires Change Tracking\\nThis method requires `trackChanges = true` in [AlloyECS.createWorld] config.\\n:::\\n\\n```lua\\nfor _, entityId in world:removed(Health) do\\n\\tprint(\\"Entity lost Health:\\", entityId)\\nend\\n```","params":[{"name":"componentId","desc":"The component ID to check","lua_type":"number"}],"returns":[{"desc":"Array of entity IDs that had this component removed","lua_type":"{number}"}],"function_type":"method","tags":["Reactive"],"source":{"line":1399,"path":"src/init.luau"}},{"name":"changed","desc":"Returns entities that had the specified component value changed this frame.\\n\\n:::warning Requires Change Tracking\\nThis method requires `trackChanges = true` in [AlloyECS.createWorld] config.\\n:::\\n\\n```lua\\nfor _, entityId in world:changed(Position) do\\n\\tprint(\\"Entity moved:\\", entityId)\\nend\\n```","params":[{"name":"componentId","desc":"The component ID to check","lua_type":"number"}],"returns":[{"desc":"Array of entity IDs that had this component changed","lua_type":"{number}"}],"function_type":"method","tags":["Reactive"],"source":{"line":1426,"path":"src/init.luau"}},{"name":"clearChanges","desc":"Clears all tracked changes for the current frame.\\nCall this at the end of each frame after processing changes.\\n\\n:::tip Automatic Clearing\\n[World:step] calls this automatically. Only call manually if you\'re\\nnot using `step()`.\\n:::\\n\\n```lua\\n-- Process changes\\nfor _, entityId in world:added(Position) do\\n\\t-- Handle new positions\\nend\\n\\n-- Clear for next frame\\nworld:clearChanges()\\n```","params":[],"returns":[],"function_type":"method","tags":["Reactive"],"source":{"line":1457,"path":"src/init.luau"}},{"name":"defer","desc":"Enables deferred mode. In deferred mode, use the `defer*` methods\\nto queue operations that will be executed when [World:flush] is called.\\n\\n:::info Use Case\\nDeferred operations are useful during iteration when you can\'t safely\\nmodify entities being queried.\\n:::","params":[],"returns":[],"function_type":"method","tags":["Deferred"],"source":{"line":1478,"path":"src/init.luau"}},{"name":"deferSpawn","desc":"Queues an entity spawn operation. The callback receives the entity ID when flushed.\\n\\n```lua\\nworld:deferSpawn(function(entityId)\\n\\tworld:deferSet(entityId, Position, Vector3.zero)\\nend)\\n```","params":[{"name":"callback","desc":"Optional callback with the new entity ID","lua_type":"((entityId: number) -> ())?"}],"returns":[{"desc":"Returns self for chaining","lua_type":"World"}],"function_type":"method","tags":["Deferred"],"source":{"line":1497,"path":"src/init.luau"}},{"name":"deferDestroy","desc":"Queues an entity destroy operation.\\n\\n```lua\\nfor entityId, health in world:query(Health) do\\n\\tif health <= 0 then\\n\\t\\tworld:deferDestroy(entityId)\\n\\tend\\nend\\nworld:flush()\\n```","params":[{"name":"entityId","desc":"The entity to destroy","lua_type":"number"}],"returns":[{"desc":"Returns self for chaining","lua_type":"World"}],"function_type":"method","tags":["Deferred"],"source":{"line":1520,"path":"src/init.luau"}},{"name":"deferAdd","desc":"Queues a component add operation.\\n\\n```lua\\nworld:deferAdd(entity, Player)\\n```","params":[{"name":"entityId","desc":"The entity to add the component to","lua_type":"number"},{"name":"componentId","desc":"The component to add","lua_type":"number"}],"returns":[{"desc":"Returns self for chaining","lua_type":"World"}],"function_type":"method","tags":["Deferred"],"source":{"line":1539,"path":"src/init.luau"}},{"name":"deferSet","desc":"Queues a component set operation.\\n\\n```lua\\nworld:deferSet(entity, Position, newPosition)\\n```","params":[{"name":"entityId","desc":"The entity to set the component on","lua_type":"number"},{"name":"componentId","desc":"The component ID","lua_type":"number"},{"name":"value","desc":"The value to set","lua_type":"any"}],"returns":[{"desc":"Returns self for chaining","lua_type":"World"}],"function_type":"method","tags":["Deferred"],"source":{"line":1559,"path":"src/init.luau"}},{"name":"deferRemove","desc":"Queues a component remove operation.\\n\\n```lua\\nworld:deferRemove(entity, Velocity)\\n```","params":[{"name":"entityId","desc":"The entity to remove the component from","lua_type":"number"},{"name":"componentId","desc":"The component to remove","lua_type":"number"}],"returns":[{"desc":"Returns self for chaining","lua_type":"World"}],"function_type":"method","tags":["Deferred"],"source":{"line":1578,"path":"src/init.luau"}},{"name":"flush","desc":"Executes all queued deferred operations and exits deferred mode.\\n\\n:::tip Automatic Flushing\\n[World:step] calls flush automatically. Only call manually if you\'re\\nnot using `step()`.\\n:::\\n\\n```lua\\nworld:defer()\\nworld:deferSpawn()\\nworld:deferSet(entity, Position, pos)\\nworld:flush() -- All operations execute here\\n```","params":[],"returns":[],"function_type":"method","tags":["Deferred"],"source":{"line":1602,"path":"src/init.luau"}},{"name":"hasPendingCommands","desc":"Checks if there are any pending deferred commands to execute.\\n\\n```lua\\nif world:hasPendingCommands() then\\n\\tworld:flush()\\nend\\n```","params":[],"returns":[{"desc":"True if there are pending deferred commands","lua_type":"boolean"}],"function_type":"method","tags":["Deferred"],"source":{"line":1638,"path":"src/init.luau"}},{"name":"addSystem","desc":"Adds a system to the scheduler. Systems are batched by phase and can run\\nin parallel if they don\'t have conflicting dependencies.\\n\\n| Phase | Description |\\n|-------|-------------|\\n| `\\"PreUpdate\\"` | Before main update logic |\\n| `\\"Update\\"` | Main game logic |\\n| `\\"PostUpdate\\"` | After main update logic |\\n| `\\"PreRender\\"` | Before rendering |\\n| `\\"Render\\"` | Rendering logic |\\n\\n```lua\\nworld:addSystem(\\"Movement\\", \\"Update\\", {\\n\\treads = { Position, Velocity },\\n\\twrites = { Position }\\n}, function(dt)\\n\\tfor entityId, pos, vel in world:query(Position, Velocity) do\\n\\t\\tworld:set(entityId, Position, pos + vel * dt)\\n\\tend\\nend)\\n```","params":[{"name":"name","desc":"Unique name for the system","lua_type":"string"},{"name":"phase","desc":"Execution phase","lua_type":"\\"PreUpdate\\" | \\"Update\\" | \\"PostUpdate\\" | \\"PreRender\\" | \\"Render\\""},{"name":"dependencies","desc":"Component dependencies","lua_type":"{ reads: {number}?, writes: {number}? }"},{"name":"callback","desc":"System function","lua_type":"(deltaTime: number) -> ()"}],"returns":[{"desc":"The created system","lua_type":"System"}],"function_type":"method","tags":["System"],"source":{"line":1674,"path":"src/init.luau"}},{"name":"removeSystem","desc":"Removes a system from the scheduler.\\n\\n```lua\\nworld:removeSystem(\\"Movement\\")\\n```","params":[{"name":"name","desc":"The name of the system to remove","lua_type":"string"}],"returns":[{"desc":"True if the system was found and removed","lua_type":"boolean"}],"function_type":"method","tags":["System"],"source":{"line":1697,"path":"src/init.luau"}},{"name":"enableSystem","desc":"Enables a previously disabled system.\\n\\n```lua\\nworld:enableSystem(\\"AI\\")\\n```","params":[{"name":"name","desc":"The name of the system to enable","lua_type":"string"}],"returns":[{"desc":"True if the system was found and enabled","lua_type":"boolean"}],"function_type":"method","tags":["System"],"source":{"line":1714,"path":"src/init.luau"}},{"name":"disableSystem","desc":"Disables a system without removing it. Disabled systems won\'t run.\\n\\n:::tip Use Case\\nUseful for pausing specific systems, e.g., disabling AI during cutscenes.\\n:::\\n\\n```lua\\nworld:disableSystem(\\"AI\\")\\n```","params":[{"name":"name","desc":"The name of the system to disable","lua_type":"string"}],"returns":[{"desc":"True if the system was found and disabled","lua_type":"boolean"}],"function_type":"method","tags":["System"],"source":{"line":1735,"path":"src/init.luau"}},{"name":"runSystems","desc":"Runs all enabled systems in all phases.\\n\\n:::tip Use step() Instead\\n[World:step] handles flushing, running systems, and clearing changes.\\nUse this only if you need manual control.\\n:::","params":[{"name":"deltaTime","desc":"Time since last frame","lua_type":"number"}],"returns":[],"function_type":"method","tags":["System"],"source":{"line":1752,"path":"src/init.luau"}},{"name":"runPhase","desc":"Runs all enabled systems in a specific phase only.\\n\\n```lua\\n-- Run only render systems\\nworld:runPhase(\\"Render\\", dt)\\n```","params":[{"name":"phase","desc":"The phase to run","lua_type":"\\"PreUpdate\\" | \\"Update\\" | \\"PostUpdate\\" | \\"PreRender\\" | \\"Render\\""},{"name":"deltaTime","desc":"Time since last frame","lua_type":"number"}],"returns":[],"function_type":"method","tags":["System"],"source":{"line":1770,"path":"src/init.luau"}},{"name":"step","desc":"Performs a complete world update step:\\n\\n1. Flushes any pending deferred commands ([World:flush])\\n2. Runs all systems ([World:runSystems])\\n3. Clears change tracking ([World:clearChanges])\\n\\n```lua\\nRunService.Heartbeat:Connect(function(dt)\\n\\tworld:step(dt)\\nend)\\n```","params":[{"name":"deltaTime","desc":"Time since last frame","lua_type":"number"}],"returns":[],"function_type":"method","tags":["System"],"source":{"line":1792,"path":"src/init.luau"}},{"name":"relate","desc":"Creates a relationship between two entities.\\nRelationships can optionally store data.\\n\\n:::info Relation Types\\nUse [World:component] to create relation types. They work like components\\nbut connect two entities together.\\n:::\\n\\n```lua\\nlocal ChildOf = world:component()\\nlocal Likes = world:component()\\n\\n-- Simple relationship\\nworld:relate(child, ChildOf, parent)\\n\\n-- Relationship with data\\nworld:relate(player, Likes, item, { amount = 10 })\\n\\n-- Get all children\\nfor _, child in world:getSources(ChildOf, parent) do\\n\\tprint(\\"Child:\\", child)\\nend\\n```","params":[{"name":"source","desc":"The source entity","lua_type":"number"},{"name":"relation","desc":"The relation type (a component ID)","lua_type":"number"},{"name":"target","desc":"The target entity","lua_type":"number"},{"name":"value","desc":"Optional data to store with the relationship","lua_type":"any?"}],"returns":[],"function_type":"method","tags":["Relationship"],"source":{"line":1834,"path":"src/init.luau"}},{"name":"unrelate","desc":"Removes a relationship between two entities.\\n\\n```lua\\nworld:unrelate(child, ChildOf, parent)\\n```","params":[{"name":"source","desc":"The source entity","lua_type":"number"},{"name":"relation","desc":"The relation type","lua_type":"number"},{"name":"target","desc":"The target entity","lua_type":"number"}],"returns":[],"function_type":"method","tags":["Relationship"],"source":{"line":1895,"path":"src/init.luau"}},{"name":"getRelation","desc":"Gets the data stored in a relationship, if any.\\n\\n```lua\\nlocal likeData = world:getRelation(player, Likes, item)\\nif likeData then\\n\\tprint(\\"Like amount:\\", likeData.amount)\\nend\\n```","params":[{"name":"source","desc":"The source entity","lua_type":"number"},{"name":"relation","desc":"The relation type","lua_type":"number"},{"name":"target","desc":"The target entity","lua_type":"number"}],"returns":[{"desc":"The relationship data, or nil","lua_type":"any"}],"function_type":"method","tags":["Relationship"],"source":{"line":1942,"path":"src/init.luau"}},{"name":"hasRelation","desc":"Checks if a relationship exists between two entities.\\n\\n```lua\\nif world:hasRelation(child, ChildOf, parent) then\\n\\tprint(\\"Is a child of parent\\")\\nend\\n```","params":[{"name":"source","desc":"The source entity","lua_type":"number"},{"name":"relation","desc":"The relation type","lua_type":"number"},{"name":"target","desc":"The target entity","lua_type":"number"}],"returns":[{"desc":"True if the relationship exists","lua_type":"boolean"}],"function_type":"method","tags":["Relationship"],"source":{"line":1974,"path":"src/init.luau"}},{"name":"getTargets","desc":"Gets all target entities that the source has a relationship with.\\n\\n```lua\\n-- Get all items this player likes\\nlocal likedItems = world:getTargets(player, Likes)\\nfor _, item in likedItems do\\n\\tprint(\\"Likes:\\", item)\\nend\\n```","params":[{"name":"source","desc":"The source entity","lua_type":"number"},{"name":"relation","desc":"The relation type","lua_type":"number"}],"returns":[{"desc":"Array of target entity IDs","lua_type":"{number}"}],"function_type":"method","tags":["Relationship"],"source":{"line":2006,"path":"src/init.luau"}},{"name":"getSources","desc":"Gets all source entities that have a relationship to the target.\\n\\n```lua\\n-- Get all children of this parent\\nlocal children = world:getSources(ChildOf, parent)\\nfor _, child in children do\\n\\tprint(\\"Child:\\", child)\\nend\\n```","params":[{"name":"relation","desc":"The relation type","lua_type":"number"},{"name":"target","desc":"The target entity","lua_type":"number"}],"returns":[{"desc":"Array of source entity IDs","lua_type":"{number}"}],"function_type":"method","tags":["Relationship"],"source":{"line":2043,"path":"src/init.luau"}},{"name":"prefab","desc":"Creates a new prefab builder or retrieves an existing prefab by name.\\nPrefabs are templates for spawning entities with predefined components.\\n\\n:::info Builder Pattern\\nThe prefab builder uses a fluent interface:\\n- `:with(componentId, value?)` - Add a component or tag\\n- `:build(name?)` - Build the prefab, optionally registering by name\\n:::\\n\\n```lua\\n-- Create and register a prefab\\nlocal enemyPrefab = world:prefab()\\n\\t:with(Health, 100)\\n\\t:with(Position, Vector3.zero)\\n\\t:with(Enemy)\\n\\t:build(\\"Enemy\\")\\n\\n-- Spawn from the prefab\\nlocal enemy = world:spawn(\\"Enemy\\")\\n\\n-- Retrieve existing prefab by name\\nlocal existingPrefab = world:prefab(\\"Enemy\\")\\n```","params":[{"name":"name","desc":"Optional name to retrieve a registered prefab","lua_type":"string?"}],"returns":[{"desc":"A builder or existing prefab data","lua_type":"PrefabBuilder | PrefabData"}],"function_type":"method","tags":["Prefab"],"source":{"line":2110,"path":"src/init.luau"}},{"name":"spawn","desc":"Spawns a new entity from a prefab template.\\nThis will trigger [World:onAdd] hooks for all components in the prefab.\\n\\n```lua\\n-- Spawn from registered name\\nlocal enemy = world:spawn(\\"Enemy\\")\\n\\n-- Spawn from prefab object\\nlocal enemy2 = world:spawn(enemyPrefab)\\n\\n-- Customize after spawning\\nworld:set(enemy, Position, Vector3.new(10, 0, 0))\\n```","params":[{"name":"prefabOrName","desc":"A prefab object or registered name","lua_type":"PrefabData | string"}],"returns":[{"desc":"The spawned entity ID","lua_type":"number"}],"function_type":"method","tags":["Prefab"],"source":{"line":2145,"path":"src/init.luau"}},{"name":"onAdd","desc":"Registers a callback that fires when a component is added to any entity.\\nReturns a function to unsubscribe.\\n\\n:::info When It Fires\\nFires on [World:add], [World:set] (for new components), and [World:spawn].\\n:::\\n\\n```lua\\nlocal unsubscribe = world:onAdd(Position, function(entityId, value)\\n\\tprint(\\"Entity\\", entityId, \\"gained Position:\\", value)\\nend)\\n\\n-- Later, to stop listening:\\nunsubscribe()\\n```","params":[{"name":"componentId","desc":"The component to watch","lua_type":"number"},{"name":"callback","desc":"Called when component is added","lua_type":"(entityId: number, value: any) -> ()"}],"returns":[{"desc":"Unsubscribe function","lua_type":"() -> ()"}],"function_type":"method","tags":["Event"],"source":{"line":2202,"path":"src/init.luau"}},{"name":"onRemove","desc":"Registers a callback that fires when a component is removed from any entity.\\nThe callback receives the old value before removal.\\n\\n:::info When It Fires\\nFires on [World:remove] and [World:destroy] (for all components).\\n:::\\n\\n```lua\\nworld:onRemove(Health, function(entityId, oldValue)\\n\\tif oldValue <= 0 then\\n\\t\\tprint(\\"Entity\\", entityId, \\"died!\\")\\n\\tend\\nend)\\n```","params":[{"name":"componentId","desc":"The component to watch","lua_type":"number"},{"name":"callback","desc":"Called when component is removed","lua_type":"(entityId: number, value: any) -> ()"}],"returns":[{"desc":"Unsubscribe function","lua_type":"() -> ()"}],"function_type":"method","tags":["Event"],"source":{"line":2245,"path":"src/init.luau"}},{"name":"onChange","desc":"Registers a callback that fires when a component value is changed.\\nOnly fires for components that already exist (not on initial add).\\n\\n:::info When It Fires\\nFires on [World:set] when updating an existing component value.\\n:::\\n\\n```lua\\nworld:onChange(Health, function(entityId, oldHealth, newHealth)\\n\\tif newHealth < oldHealth then\\n\\t\\tprint(\\"Entity\\", entityId, \\"took\\", oldHealth - newHealth, \\"damage!\\")\\n\\tend\\nend)\\n```","params":[{"name":"componentId","desc":"The component to watch","lua_type":"number"},{"name":"callback","desc":"Called when component changes","lua_type":"(entityId: number, oldValue: any, newValue: any) -> ()"}],"returns":[{"desc":"Unsubscribe function","lua_type":"() -> ()"}],"function_type":"method","tags":["Event"],"source":{"line":2288,"path":"src/init.luau"}},{"name":"serialize","desc":"Serializes the entire world state to a table that can be saved.\\nUse typeHandlers to convert non-serializable types like Vector3.\\n\\n:::warning Custom Types\\nRoblox types like Vector3, CFrame, etc. must be converted using typeHandlers\\nor they won\'t serialize properly.\\n:::\\n\\n```lua\\nlocal data = world:serialize({\\n\\tVector3 = function(v)\\n\\t\\treturn { x = v.X, y = v.Y, z = v.Z }\\n\\tend,\\n})\\n\\n-- Save data to DataStore, file, etc.\\n```","params":[{"name":"typeHandlers","desc":"Optional handlers for custom types","lua_type":"{ [string]: (any) -> any }?"}],"returns":[{"desc":"The serialized world state","lua_type":"SerializedWorld"}],"function_type":"method","tags":["Persistence"],"source":{"line":2333,"path":"src/init.luau"}},{"name":"deserialize","desc":"Restores world state from serialized data.\\n\\n:::danger Clears Existing Data\\nThis clears all existing entities, components, and relationships\\nbefore loading the serialized data.\\n:::\\n\\n```lua\\nworld:deserialize(savedData, {\\n\\tVector3 = function(v)\\n\\t\\tif v.x then\\n\\t\\t\\treturn Vector3.new(v.x, v.y, v.z)\\n\\t\\tend\\n\\t\\treturn nil\\n\\tend,\\n})\\n```","params":[{"name":"data","desc":"The serialized world state","lua_type":"SerializedWorld"},{"name":"typeHandlers","desc":"Optional handlers to reconstruct custom types","lua_type":"{ [string]: (any) -> any }?"}],"returns":[],"function_type":"method","tags":["Persistence"],"source":{"line":2413,"path":"src/init.luau"}},{"name":"each","desc":"Iterates over all living entities in the world.\\n\\n:::tip Alternative\\nFor filtering entities by component, use [World:query] instead.\\n:::\\n\\n```lua\\nworld:each(function(entityId)\\n\\tprint(\\"Entity:\\", entityId)\\nend)\\n```","params":[{"name":"callback","desc":"Function to call for each entity","lua_type":"(entityId: number) -> ()"}],"returns":[],"function_type":"method","tags":["Entity"],"source":{"line":2517,"path":"src/init.luau"}}],"properties":[],"types":[],"name":"World","desc":"The World is the main container for all ECS data. It manages entities,\\ncomponents, queries, systems, relationships, and more.\\n\\nCreate a new world using [AlloyECS.createWorld].\\n\\n## Method Categories\\n\\n| Category | Methods |\\n|----------|----------|\\n| **Entity** | [World:entity], [World:isAlive], [World:destroy], [World:getEntityCount], [World:getEntities], [World:each] |\\n| **Component** | [World:component], [World:tag], [World:isTag], [World:add], [World:set], [World:get], [World:has], [World:remove] |\\n| **Query** | [World:query] |\\n| **System** | [World:addSystem], [World:removeSystem], [World:enableSystem], [World:disableSystem], [World:runSystems], [World:runPhase], [World:step] |\\n| **Relationship** | [World:relate], [World:unrelate], [World:getRelation], [World:hasRelation], [World:getTargets], [World:getSources] |\\n| **Prefab** | [World:prefab], [World:spawn] |\\n| **Event** | [World:onAdd], [World:onRemove], [World:onChange] |\\n| **Deferred** | [World:defer], [World:deferSpawn], [World:deferDestroy], [World:deferAdd], [World:deferSet], [World:deferRemove], [World:flush], [World:hasPendingCommands] |\\n| **Reactive** | [World:added], [World:removed], [World:changed], [World:clearChanges] |\\n| **Persistence** | [World:serialize], [World:deserialize] |\\n\\n## Example\\n\\n```lua\\nlocal AlloyECS = require(path.to.AlloyECS)\\nlocal world = AlloyECS.createWorld()\\n\\n-- Create components\\nlocal Position = world:component()\\nlocal Velocity = world:component()\\n\\n-- Create entities\\nlocal entity = world:entity()\\nworld:set(entity, Position, Vector3.new(0, 0, 0))\\nworld:set(entity, Velocity, Vector3.new(1, 0, 0))\\n\\n-- Query and update\\nfor entityId, pos, vel in world:query(Position, Velocity) do\\n\\tworld:set(entityId, Position, pos + vel)\\nend\\n```","source":{"line":171,"path":"src/init.luau"}}')}}]);